# 活跃变量分析 --- 技术报告

### 活跃变量分析原理

#### 理论概述
对于变量x和点p，在控制流图（CFG）中沿从p开始的某条路径，是否可以引用x在p点的值。如果可以则称x在p点是活跃的，否则，x在p点就是无用的。

#### 公式原理
##### 前导定义
```text
in[B]: 基本块B的入口点的活跃变量集合。
out[B]: 是在基本块B的出口点的活跃变量集。
def[B]: 是在基本块b内的定义，但是定义前在B中没有被引用的变量的集合。
use[B]: 表示在基本块中引用，但是引用前在B中没有被定义的变量集合。
其中，def[B]和use[B]是可以从基本块B中直接求得的量，因此在方程中作为已知量。
```

##### 计算公式
```
in[B] = use[B] ∪(out[B]-def[B])
out[B] = ∪ in[S]，其中S为B的所有后继。
```
**变量在某点活跃，表示变量在该点的值在以后会被使用。**
- 第一个方程表示：
	- 一个变量在进入块B时是活跃的，如果它在该块中于定义前被引用
	- 一个变量在离开块B时是活跃的，而且在该块中没有被重新定义。
- 第二个方程表示：
	- 一个变量在离开块B时是活跃的，当且仅当它在进入该块的某个后继时是活跃的。

##### 原理剖析
显然，由于每个块的**def**和**use**集合是已知的，我们的任务就是求解**out**与**in**集合。显然，简单分析两个方程，我们便知道我们应当进行的是后向数据流分析。回顾我之前的学习报告，如果我们需要进行数据流分析，我们需要确定四个问题：
1. 决定分析的本质是什么：是否向前后者向后的数据分析？是否考虑分支，还是不进行考虑？等等

2. 确定自己想进行如何粗略的估计：是可能的分析还是必不可少的分析？从效果上看，你需要决定，在合并通过一个节点的信息的时候，你是需要进行结合还是切断？

3. 执行实际上的流： 本质上是为每一个处于中间状态的 声明 建立方程式。—— 如：任务声明应该如何被操作？

4. 确定初始的状态，或者入口节点的近似（如果是回溯的流程，那么是出口节点） 以及 中间节点——（或者是空集，或者是全集，这取决于分析的粒度。）

在这里我们解决了第一个问题，这是一个后向的数据分析。那么第二个问题，这是一个may还是一个must分析呢？
```
may分析要求宽松（并集），分析的结果包含正确的答案。
must分析要求严格（交集），分析的结果一定被包含于正确答案之内。
```
通过公式2可以得知，活跃变量分析应当是一个may分析（因为我们希望知道的是那些可能作为活跃变量的变量），因此我们将会在merge函数中采用并集的操作。第三个问题其实就是当控制流'流到''结点时我们应该如何操作，显然就是做上述def/use/in/out的计算。第四个问题也十分简单，对于其初始状态，我们仅需要设置出口节点的flowset为空集即可。

#### 关键代码分析
![Alt text](./assets/1529935450071.png)

这里先贴上官方wiki对于我们写数据流分析框架的要求，可以看到我们需要重载的函数都在图上显示，接下来我们就开始进行代码分析。

- 声明
首先我们进行类声明，这个过程比较简单，在这里不做赘述
```java
class LiveVariableAnalysis extends BackwardFlowAnalysis<Unit, FlowSet<Local>> 
{
...
}
```
- construtor
接下来是构造函数，按照官方给的示例即可。
```java
public LiveVariableAnalysis(DirectedGraph g) {
	super(g);
	doAnalysis();
}
```

- newInitialFlow
这个函数用于定义每个节点的in/out集合的初始状态，很简单，在我们没有进行计算前，我们均认为他们为空
```java
@Override
protected FlowSet<Local> newInitialFlow() {
	return new ArraySparseSet<Local>();
}
```
- entryInitialFlow
这个就是要求里的第四点，同样的，空集合即可。
```java
@Override
protected FlowSet<Local> entryInitialFlow() {
	return new ArraySparseSet<Local>();
}
```

- merge
这个其实就是我们分析的第三点，由于是个may分析，我们的merge操作均采用并集的形式
```java
@Override
protected void merge(FlowSet<Local> src1, FlowSet<Local> src2, FlowSet<Local> dest) {
	// dest <- src1 U src2, 此处对应于out[B] = ∪ in[S]，其中S为B的所有后继。
	src1.union(src2, dest);
}
```

- flowthrough
这个就是我们核心操作处理，按照给出的公式进行计算即可
```
@Override
protected void flowThrough(FlowSet<Local> inSet, 
	Unit node, FlowSet<Local> outSet) {
	// 后向分析，对应于公式 in、out相反
	FlowSet defs = (FlowSet)(new ArraySparseSet<Local>());

	for (ValueBox def: node.getDefBoxes()) {
		if (def.getValue() instanceof Local) {
			defs.add((Local)def.getValue());
		}
	}
	// out <- in - def
	inSet.difference(defs, outSet);

	// out <- out ∪ use
	for (ValueBox use: node.getUseBoxes()) {
		if (use.getValue() instanceof Local) {
			outSet.add((Local) use.getValue());
		}
	}
}
```


##### Extra
- Why ArraySparseSet？
soot提供了四种FlowSet类型（关于FlowSet是什么，请查看`Soot Survivors Guide`的$5.6，这里不做赘述），我们的问题在于为什么使用这类型。这里一个关键点就是，在这样的一个分析中，我们并不能预先知道一个CFG中的节点的相关数据量的大小，因此基于此点这里便采用了ArraySparseSet。
- What is Local
代码中另外一个令人迷惑的地方可能就是关于`Local`的使用。在官方的API中，是这样写的：`A local variable, used within Body classes. Intermediate representations must use an implementation of Local for their local variables.`也就是说，每一个Local类型变量都应当是属于该结点的一个局部变量。于是联系我们的代码我们就知道了，可以通过判断 `Value`的类型来决定它是不是一个局部变量(关于`Value`类型请查看`Soot Survivors Guide`的$2.2).


#### Besides
至此，我们关于活跃变量分析的部分就已经结束了。剩下的则是如何实现可视化处理的部分，没有什么技术难点，使用这一部分可以参见用户操作手册，因此也就不再额外说明。